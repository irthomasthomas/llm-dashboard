<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Dashboard</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- DateRangePicker -->
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.css" />
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .card {
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .card-header {
            background-color: #4a6fa5;
            color: white;
            font-weight: bold;
            border-radius: 8px 8px 0 0 !important;
        }
        .filters {
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .chart-container {
            height: 300px;
            position: relative;
        }
        .stat-card {
            text-align: center;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .stat-card h3 {
            font-size: 2.2rem;
            font-weight: bold;
            margin: 10px 0;
            color: #4a6fa5;
        }
        .stat-card p {
            font-size: 1.1rem;
            color: #6c757d;
            margin: 0;
        }
        table {
            font-size: 0.9rem;
        }
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .loading-content {
            text-align: center;
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        .spinner-border {
            width: 3rem;
            height: 3rem;
        }
        .daterangepicker {
            z-index: 10000 !important;
        }
        .daily-chart-container {
            height: 400px;
            position: relative;
            margin-bottom: 30px;
        }
        .nav-pills .nav-link.active {
            background-color: #4a6fa5;
        }
        #errorAlert {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            max-width: 400px;
        }
    </style>
</head>
<body>
<script>
// Add console inspector for network requests
(function() {
    console.log('%cðŸ” Request Inspector Activated', 'background: #222; color: #bada55; font-size: 16px; padding: 5px;');
    
    // Monitor fetch calls
    const originalFetch = window.fetch;
    window.fetch = async function() {
        console.log('%câ†’ Fetch Request', 'color: #2196F3; font-weight: bold;', {
            url: arguments[0],
            options: arguments[1]
        });
        
        try {
            const response = await originalFetch.apply(this, arguments);
            
            // Clone the response so we can log it and still return a usable response
            const clone = response.clone();
            
            // Log response status
            console.log('%câ† Fetch Response', 'color: #4CAF50; font-weight: bold;', {
                url: arguments[0],
                status: clone.status,
                statusText: clone.statusText
            });
            
            // Try to log the JSON response if possible
            try {
                const jsonResponse = await clone.json();
                console.log('%câ† Response Data', 'color: #FF9800;', jsonResponse);
            } catch (e) {
                console.log('%câ† Response is not JSON', 'color: #f44336;');
            }
            
            return response;
        } catch (error) {
            console.error('%câœ– Fetch Error', 'color: #f44336; font-weight: bold;', error);
            throw error;
        }
    };
    
    // Add visualization debugging
    const originalUpdate = Chart.prototype.update;
    Chart.prototype.update = function() {
        console.log('%cðŸ“Š Chart Update', 'color: #9c27b0; font-weight: bold;', {
            id: this.canvas.id,
            data: JSON.parse(JSON.stringify(this.data)), // Deep copy to avoid circular references
            options: this.options
        });
        return originalUpdate.apply(this, arguments);
    };
    
    // Create a debugger object for direct inspection
    window.debugger = {
        checkState: function() {
            console.log('%cðŸ“Œ Current State', 'background: #222; color: #bada55;', {
                dateRange: $(dateRangePicker).data('daterangepicker') ? {
                    startDate: $(dateRangePicker).data('daterangepicker').startDate.format('YYYY-MM-DD'),
                    endDate: $(dateRangePicker).data('daterangepicker').endDate.format('YYYY-MM-DD')
                } : 'Not Initialized',
                selectedModel: $('#modelFilter').val(),
                charts: {
                    tokenUsage: tokenUsageChart ? {
                        labels: tokenUsageChart.data.labels,
                        datasets: tokenUsageChart.data.datasets
                    } : 'Not Initialized',
                    // Add other charts as needed
                }
            });
        },
        testAPI: async function(model = 'all') {
            const dateRange = $(dateRangePicker).data('daterangepicker');
            if (!dateRange) {
                console.error('Date range picker not initialized');
                return;
            }
            
            const startDate = dateRange.startDate.format('YYYY-MM-DD');
            const endDate = dateRange.endDate.format('YYYY-MM-DD');
            
            console.log('%cðŸ§ª Manual API Test', 'background: #222; color: #bada55;', {
                startDate,
                endDate,
                model
            });
            
            try {
                const url = `/api/token-data?start_date=${startDate}&end_date=${endDate}&model=${encodeURIComponent(model)}`;
                const response = await fetch(url);
                const data = await response.json();
                
                console.log('%cðŸ§ª API Test Result', 'background: #222; color: #bada55;', data);
                return data;
            } catch (error) {
                console.error('%cðŸ§ª API Test Error', 'background: #222; color: #f44336;', error);
                return null;
            }
        },
        reinitialize: function() {
            console.log('%cðŸ”„ Reinitializing Filters', 'background: #222; color: #bada55;');
            
            // Reinitialize date range picker
            initDateRangePicker();
            
            // Force reload data
            setTimeout(() => {
                loadData();
            }, 1000);
        }
    };
    
    // Add to window object
    window.inspector = {
        logVisualizations: function() {
            if (tokenUsageChart) {
                console.log('Token Usage Chart:', tokenUsageChart.data);
            }
            if (costChart) {
                console.log('Cost Chart:', costChart.data);
            }
            if (tokenDistributionChart) {
                console.log('Token Distribution Chart:', tokenDistributionChart.data);
            }
            if (costEfficiencyChart) {
                console.log('Cost Efficiency Chart:', costEfficiencyChart.data);
            }
        }
    };
    
    console.log('%cðŸ’¡ Type "debugger.checkState()" to see current state', 'color: #2196F3;');
    console.log('%cðŸ’¡ Type "debugger.testAPI()" to manually test the API', 'color: #2196F3;');
    console.log('%cðŸ’¡ Type "inspector.logVisualizations()" to inspect charts', 'color: #2196F3;');
})();

</script>

    <div class="container-fluid">
        <!-- Header -->
        <div class="row mb-4">
            <div class="col-12">
                <h1 class="text-center text-primary">LLM Dashboard</h1>
                <p class="text-center text-muted">Dynamic analysis of token usage and costs across different models</p>
            </div>
        </div>

        <!-- Filters -->
        <div class="row filters">
            <div class="col-md-5 mb-3">
                <label for="dateRangePicker" class="form-label">Date Range</label>
                <input type="text" class="form-control" id="dateRangePicker" placeholder="Select date range">
            </div>
            <div class="col-md-4 mb-3">
                <label for="modelFilter" class="form-label">Model</label>
                <select class="form-select" id="modelFilter">
                    <option value="all">All Models</option>
                    <!-- Models will be dynamically populated -->
                </select>
            </div>
            <div class="col-md-3 mb-3 d-flex align-items-end">
                <button class="btn btn-primary w-100" id="applyFilters">Apply Filters</button>
            </div>
        </div>

        <!-- Summary Stats -->
        <div class="row mb-4">
            <div class="col-md-3">
                <div class="stat-card">
                    <p>Total Requests</p>
                    <h3 id="totalRequests">0</h3>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stat-card">
                    <p>Total Tokens</p>
                    <h3 id="totalTokens">0</h3>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stat-card">
                    <p>Total Cost</p>
                    <h3 id="totalCost">$0.00</h3>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stat-card">
                    <p>Avg. Cost per Request</p>
                    <h3 id="avgCost">$0.00</h3>
                </div>
            </div>
        </div>

        <!-- Daily Trends Chart -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">Daily Trends</div>
                    <div class="card-body">
                        <ul class="nav nav-pills mb-3" id="dailyChartTab" role="tablist">
                            <li class="nav-item" role="presentation">
                                <button class="nav-link active" id="tokens-tab" data-bs-toggle="pill" data-bs-target="#tokens" type="button" role="tab" aria-controls="tokens" aria-selected="true">Token Usage</button>
                            </li>
                            <li class="nav-item" role="presentation">
                                <button class="nav-link" id="costs-tab" data-bs-toggle="pill" data-bs-target="#costs" type="button" role="tab" aria-controls="costs" aria-selected="false">Costs</button>
                            </li>
                            <li class="nav-item" role="presentation">
                                <button class="nav-link" id="requests-tab" data-bs-toggle="pill" data-bs-target="#requests" type="button" role="tab" aria-controls="requests" aria-selected="false">Requests</button>
                            </li>
                        </ul>
                        <div class="tab-content" id="dailyChartTabContent">
                            <div class="tab-pane fade show active" id="tokens" role="tabpanel" aria-labelledby="tokens-tab">
                                <div class="daily-chart-container">
                                    <canvas id="dailyTokenChart"></canvas>
                                </div>
                            </div>
                            <div class="tab-pane fade" id="costs" role="tabpanel" aria-labelledby="costs-tab">
                                <div class="daily-chart-container">
                                    <canvas id="dailyCostChart"></canvas>
                                </div>
                            </div>
                            <div class="tab-pane fade" id="requests" role="tabpanel" aria-labelledby="requests-tab">
                                <div class="daily-chart-container">
                                    <canvas id="dailyRequestChart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Charts -->
        <div class="row">
            <!-- Token Usage by Model -->
            <div class="col-md-6 mb-4">
                <div class="card">
                    <div class="card-header">Token Usage by Model</div>
                    <div class="card-body">
                        <div class="chart-container">
                            <canvas id="tokenUsageChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Cost by Model -->
            <div class="col-md-6 mb-4">
                <div class="card">
                    <div class="card-header">Cost by Model</div>
                    <div class="card-body">
                        <div class="chart-container">
                            <canvas id="costChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Token Distribution -->
            <div class="col-md-6 mb-4">
                <div class="card">
                    <div class="card-header">Token Distribution (Prompt vs Completion)</div>
                    <div class="card-body">
                        <div class="chart-container">
                            <canvas id="tokenDistributionChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Cost Efficiency -->
            <div class="col-md-6 mb-4">
                <div class="card">
                    <div class="card-header">Cost per 1K Tokens by Model</div>
                    <div class="card-body">
                        <div class="chart-container">
                            <canvas id="costEfficiencyChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- High Cost Requests -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">Top 10 Highest Cost Requests</div>
                    <div class="card-body">
                        <div class="table-responsive">
                            <table class="table table-striped table-hover" id="highCostTable">
                                <thead>
                                    <tr>
                                        <th>ID</th>
                                        <th>Model</th>
                                        <th>Prompt Tokens</th>
                                        <th>Completion Tokens</th>
                                        <th>Total Tokens</th>
                                        <th>Cost ($)</th>
                                        <th>Date & Time</th>
                                    </tr>
                                </thead>
                                <tbody id="highCostTableBody">
                                    <!-- Table data will be dynamically populated -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Data Table -->
        <div class="row">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">Model Summary</div>
                    <div class="card-body">
                        <div class="table-responsive">
                            <table class="table table-striped table-hover" id="dataTable">
                                <thead>
                                    <tr>
                                        <th>Model</th>
                                        <th>Requests</th>
                                        <th>Prompt Tokens</th>
                                        <th>Completion Tokens</th>
                                        <th>Total Tokens</th>
                                        <th>Total Cost ($)</th>
                                        <th>Avg Cost/Request ($)</th>
                                        <th>Cost per 1K Tokens ($)</th>
                                    </tr>
                                </thead>
                                <tbody id="tableBody">
                                    <!-- Table data will be dynamically populated -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Error Alert -->
    <div class="alert alert-danger alert-dismissible fade" role="alert" id="errorAlert">
        <div id="errorMessage"></div>
        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    </div>

    <!-- Loading Overlay -->
    <div class="loading" id="loadingOverlay">
        <div class="loading-content">
            <div class="spinner-border text-primary mb-3" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <h5 id="loadingMessage">Loading Data...</h5>
        </div>
    </div>

    <!-- Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <!-- jQuery (required for DateRangePicker) -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <!-- Moment.js (required for DateRangePicker) -->
    <script src="https://cdn.jsdelivr.net/momentjs/latest/moment.min.js"></script>
    <!-- DateRangePicker -->
    <script src="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.min.js"></script>
    
    <script>
        // Charts instances
        let tokenUsageChart, costChart, tokenDistributionChart, costEfficiencyChart;
        let dailyTokenChart, dailyCostChart, dailyRequestChart;
        
        // DOM elements
        const dateRangePicker = document.getElementById('dateRangePicker');
        const modelFilter = document.getElementById('modelFilter');
        const applyFiltersBtn = document.getElementById('applyFilters');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingMessage = document.getElementById('loadingMessage');
        const errorAlert = document.getElementById('errorAlert');
        const errorMessage = document.getElementById('errorMessage');
        
        // Stats elements
        const totalRequestsEl = document.getElementById('totalRequests');
        const totalTokensEl = document.getElementById('totalTokens');
        const totalCostEl = document.getElementById('totalCost');
        const avgCostEl = document.getElementById('avgCost');
        
        // Table bodies
        const tableBody = document.getElementById('tableBody');
        const highCostTableBody = document.getElementById('highCostTableBody');

        // Date range for filtering
        let startDate = moment().subtract(7, 'days').format('YYYY-MM-DD');
        let endDate = moment().format('YYYY-MM-DD');

        // Initialize DateRangePicker
        // Original initDateRangePicker replaced
async function initDateRangePicker() {
            showLoading('Loading available date range...');
            
            // First fetch available date range from API
            fetch('/api/date-range')
                .then(response => response.json())
                .then(data => {
                    hideLoading();
                    
                    if (data.success) {
                        const minDate = data.min_date ? moment(data.min_date) : moment().subtract(30, 'days');
                        const maxDate = data.max_date ? moment(data.max_date) : moment();
                        
                        // Set default selection to last 7 days or available range if shorter
                        startDate = moment(maxDate).subtract(7, 'days').isBefore(minDate) 
                            ? minDate.format('YYYY-MM-DD')
                            : moment(maxDate).subtract(7, 'days').format('YYYY-MM-DD');
                        endDate = maxDate.format('YYYY-MM-DD');
                        
                        // Initialize daterangepicker
                        $(dateRangePicker).daterangepicker({
                            autoApply: true,
                            showDropdowns: true,
                            alwaysShowCalendars: true,
                            startDate: moment(startDate),
                            endDate: moment(endDate),
                            minDate: minDate,
                            maxDate: maxDate,
                            opens: 'left',
                            locale: {
                                format: 'YYYY-MM-DD'
                            }
                        }, function(start, end) {
                            startDate = start.format('YYYY-MM-DD');
                            endDate = end.format('YYYY-MM-DD');
                        });
                        
                        // Load models
                        loadModels();
                    } else {
                        showError('Failed to load date range: ' + (data.error || 'Unknown error'));
                    }
                })
                .catch(error => {
                    hideLoading();
                    showError('Failed to connect to API: ' + error.message);
                });
        }

        // Load available models
        // Original loadModels replaced
async function loadModels() {
            showLoading('Loading models...');
            
            fetch('/api/models')
                .then(response => response.json())
                .then(data => {
                    hideLoading();
                    
                    if (data.success) {
                        modelFilter.innerHTML = '<option value="all">All Models</option>';
                        
                        data.models.forEach(model => {
                            const option = document.createElement('option');
                            option.value = model;
                            option.textContent = model;
                            modelFilter.appendChild(option);
                        });
                        
                        // Initial data load
                        loadData();
                    } else {
                        showError('Failed to load models: ' + (data.error || 'Unknown error'));
                    }
                })
                .catch(error => {
                    hideLoading();
                    showError('Failed to connect to API: ' + error.message);
                });
        }

        // Load token usage data
        // Original loadData replaced
async function loadData() {
            showLoading('Loading token usage data...');
            
            const modelSelection = modelFilter.value;
            
            const url = `/api/token-data?start_date=${startDate}&end_date=${endDate}&model=${modelSelection}`;
            
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        updateVisualizations(data);
                        loadHighCostRecords();
                    } else {
                        hideLoading();
                        showError('Failed to load data: ' + (data.error || 'Unknown error'));
                    }
                })
                .catch(error => {
                    hideLoading();
                    showError('Failed to connect to API: ' + error.message);
                });
        }

        // Load high cost records
        // Original loadHighCostRecords replaced
async function loadHighCostRecords() {
            showLoading('Loading high-cost records...');
            
            const modelSelection = modelFilter.value;
            
            const url = `/api/sample-records?start_date=${startDate}&end_date=${endDate}&model=${modelSelection}`;
            
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    hideLoading();
                    
                    if (data.success) {
                        updateHighCostTable(data.records);
                    } else {
                        showError('Failed to load high-cost records: ' + (data.error || 'Unknown error'));
                    }
                })
                .catch(error => {
                    hideLoading();
                    showError('Failed to connect to API: ' + error.message);
                });
        }

        // Initialize charts
        function initCharts() {
            // Token Usage Chart
            tokenUsageChart = new Chart(document.getElementById('tokenUsageChart'), {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Prompt Tokens',
                            backgroundColor: '#4a6fa5',
                            data: []
                        },
                        {
                            label: 'Completion Tokens',
                            backgroundColor: '#ff9642',
                            data: []
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Token Usage by Model'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += new Intl.NumberFormat().format(context.parsed.y);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Model'
                            }
                        },
                        y: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Number of Tokens'
                            },
                            ticks: {
                                callback: function(value) {
                                    return new Intl.NumberFormat().format(value);
                                }
                            }
                        }
                    }
                }
            });

            // Cost Chart
            costChart = new Chart(document.getElementById('costChart'), {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Total Cost ($)',
                        backgroundColor: '#2ca02c',
                        data: []
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Cost by Model'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': $';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Cost ($)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toFixed(2);
                                }
                            }
                        }
                    }
                }
            });

            // Token Distribution Chart
            tokenDistributionChart = new Chart(document.getElementById('tokenDistributionChart'), {
                type: 'pie',
                data: {
                    labels: ['Prompt Tokens', 'Completion Tokens'],
                    datasets: [{
                        label: 'Tokens',
                        backgroundColor: ['#4a6fa5', '#ff9642'],
                        data: [0, 0]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Token Distribution'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.raw;
                                    const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                                    const percentage = Math.round((value / total) * 100);
                                    return `${label}: ${new Intl.NumberFormat().format(value)} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });

            // Cost Efficiency Chart
            costEfficiencyChart = new Chart(document.getElementById('costEfficiencyChart'), {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Cost per 1K Tokens ($)',
                        backgroundColor: '#d62728',
                        data: []
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Cost per 1K Tokens by Model'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': $';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(6);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Cost per 1K Tokens ($)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toFixed(6);
                                }
                            }
                        }
                    }
                }
            });

            // Daily Token Chart
            dailyTokenChart = new Chart(document.getElementById('dailyTokenChart'), {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Prompt Tokens',
                            backgroundColor: '#4a6fa5',
                            data: [],
                            order: 1
                        },
                        {
                            label: 'Completion Tokens',
                            backgroundColor: '#ff9642',
                            data: [],
                            order: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Daily Token Usage'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += new Intl.NumberFormat().format(context.parsed.y);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        },
                        y: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Number of Tokens'
                            },
                            ticks: {
                                callback: function(value) {
                                    return new Intl.NumberFormat().format(value);
                                }
                            }
                        }
                    }
                }
            });

            // Daily Cost Chart
            dailyCostChart = new Chart(document.getElementById('dailyCostChart'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Total Cost ($)',
                        borderColor: '#2ca02c',
                        backgroundColor: 'rgba(44, 160, 44, 0.2)',
                        data: [],
                        tension: 0.1,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Daily Cost'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': $';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(2);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Cost ($)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toFixed(2);
                                }
                            }
                        }
                    }
                }
            });

            // Daily Request Chart
            dailyRequestChart = new Chart(document.getElementById('dailyRequestChart'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Number of Requests',
                        borderColor: '#9467bd',
                        backgroundColor: 'rgba(148, 103, 189, 0.2)',
                        data: [],
                        tension: 0.1,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Daily Requests'
                        }
                    },
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Number of Requests'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // Format numbers for display
        function formatNumber(num) {
            return new Intl.NumberFormat().format(Math.round(num));
        }

        function formatCurrency(num) {
            return '$' + num.toFixed(2);
        }

        // Update summary stats
        function updateSummaryStats(stats) {
            totalRequestsEl.textContent = formatNumber(stats.total_requests);
            totalTokensEl.textContent = formatNumber(stats.total_tokens);
            totalCostEl.textContent = formatCurrency(stats.total_cost);
            avgCostEl.textContent = formatCurrency(stats.avg_cost_per_request);
        }

        // Update token usage chart
        function updateTokenUsageChart(data) {
            const models = data.map(item => {
                const parts = item.model.split('/');
                return parts.length > 1 ? parts[parts.length - 1] : item.model;
            });
            const promptTokens = data.map(item => item.prompt_tokens);
            const completionTokens = data.map(item => item.completion_tokens);
            
            tokenUsageChart.data.labels = models;
            tokenUsageChart.data.datasets[0].data = promptTokens;
            tokenUsageChart.data.datasets[1].data = completionTokens;
            tokenUsageChart.update();
        }

        // Update cost chart
        function updateCostChart(data) {
            const models = data.map(item => {
                const parts = item.model.split('/');
                return parts.length > 1 ? parts[parts.length - 1] : item.model;
            });
            const costs = data.map(item => item.total_cost);
            
            costChart.data.labels = models;
            costChart.data.datasets[0].data = costs;
            costChart.update();
        }

        // Update token distribution chart
        function updateTokenDistributionChart(stats) {
            tokenDistributionChart.data.datasets[0].data = [
                stats.total_prompt_tokens,
                stats.total_completion_tokens
            ];
            tokenDistributionChart.update();
        }

        // Update cost efficiency chart
        function updateCostEfficiencyChart(data) {
            const models = data.map(item => {
                const parts = item.model.split('/');
                return parts.length > 1 ? parts[parts.length - 1] : item.model;
            });
            const costPer1kTokens = data.map(item => item.cost_per_1k_tokens);
            
            costEfficiencyChart.data.labels = models;
            costEfficiencyChart.data.datasets[0].data = costPer1kTokens;
            costEfficiencyChart.update();
        }

        // Update daily charts
        function updateDailyCharts(data) {
            const dates = data.map(item => item.date);
            const promptTokens = data.map(item => item.prompt_tokens);
            const completionTokens = data.map(item => item.completion_tokens);
            const costs = data.map(item => item.total_cost);
            const requests = data.map(item => item.requests);
            
            // Update token chart
            dailyTokenChart.data.labels = dates;
            dailyTokenChart.data.datasets[0].data = promptTokens;
            dailyTokenChart.data.datasets[1].data = completionTokens;
            dailyTokenChart.update();
            
            // Update cost chart
            dailyCostChart.data.labels = dates;
            dailyCostChart.data.datasets[0].data = costs;
            dailyCostChart.update();
            
            // Update request chart
            dailyRequestChart.data.labels = dates;
            dailyRequestChart.data.datasets[0].data = requests;
            dailyRequestChart.update();
        }

        // Update data table
        function updateDataTable(data) {
            tableBody.innerHTML = '';
            
            data.forEach(item => {
                const row = document.createElement('tr');
                
                row.innerHTML = `
                    <td>${item.model}</td>
                    <td>${formatNumber(item.requests)}</td>
                    <td>${formatNumber(item.prompt_tokens)}</td>
                    <td>${formatNumber(item.completion_tokens)}</td>
                    <td>${formatNumber(item.total_tokens)}</td>
                    <td>${formatCurrency(item.total_cost)}</td>
                    <td>${formatCurrency(item.avg_cost_per_request)}</td>
                    <td>${formatCurrency(item.cost_per_1k_tokens)}</td>
                `;
                
                tableBody.appendChild(row);
            });
        }

        // Update high cost table
        function updateHighCostTable(data) {
            highCostTableBody.innerHTML = '';
            
            data.forEach(item => {
                const row = document.createElement('tr');
                
                row.innerHTML = `
                    <td>${item.id}</td>
                    <td>${item.model}</td>
                    <td>${formatNumber(item.prompt_tokens)}</td>
                    <td>${formatNumber(item.completion_tokens)}</td>
                    <td>${formatNumber(item.total_tokens)}</td>
                    <td>${formatCurrency(item.cost)}</td>
                    <td>${item.datetime}</td>
                `;
                
                highCostTableBody.appendChild(row);
            });
        }

        // Update all visualizations
        function updateVisualizations(data) {
            const modelData = data.model_data;
            const overallStats = data.overall_stats;
            const dateData = data.date_data;
            
            updateSummaryStats(overallStats);
            updateTokenUsageChart(modelData);
            updateCostChart(modelData);
            updateTokenDistributionChart(overallStats);
            updateCostEfficiencyChart(modelData);
            updateDataTable(modelData);
            
            if (dateData && dateData.length > 0) {
                updateDailyCharts(dateData);
            }
        }

        // Show loading overlay
        function showLoading(message = 'Loading...') {
            loadingMessage.textContent = message;
            loadingOverlay.style.display = 'flex';
        }

        // Hide loading overlay
        function hideLoading() {
            loadingOverlay.style.display = 'none';
        }

        // Show error message
        function showError(message) {
            errorMessage.textContent = message;
            errorAlert.classList.add('show');
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                errorAlert.classList.remove('show');
            }, 5000);
        }

        // Event listeners
        applyFiltersBtn.addEventListener('click', function() {
            const dateRange = $(dateRangePicker).data('daterangepicker');
            startDate = dateRange.startDate.format('YYYY-MM-DD');
            endDate = dateRange.endDate.format('YYYY-MM-DD');
            
            loadData();
        });

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize charts
            initCharts();
            
            // Initialize date range picker
            setTimeout(initDateRangePicker, 100);
        });
    </script>

// Add this before the closing 
<script>
// Enhanced event handling for filters
document.addEventListener('DOMContentLoaded', function() {
    // Ensure we have the elements
    const modelFilter = document.getElementById('modelFilter');
    const applyFiltersBtn = document.getElementById('applyFilters');
    
    if (!modelFilter || !applyFiltersBtn) {
        console.error('Could not find filter elements!');
        return;
    }
    
    console.log('Setting up enhanced filter event handlers');
    
    // Add change event logging for debugging
    modelFilter.addEventListener('change', function() {
        console.log('Model filter changed to:', this.value);
    });
    
    // Replace the click handler for Apply Filters button
    // Remove any existing event listeners first (if possible)
    applyFiltersBtn.replaceWith(applyFiltersBtn.cloneNode(true));
    
    // Get the fresh button reference and add a new listener
    const freshApplyBtn = document.getElementById('applyFilters');
    freshApplyBtn.addEventListener('click', function() {
        console.log('Apply Filters button clicked');
        console.log('Current model filter:', modelFilter.value);
        
        // Get the current date range
        const dateRange = $(dateRangePicker).data('daterangepicker');
        if (!dateRange) {
            console.error('Could not get daterangepicker data!');
            showError('Date range picker is not initialized properly.');
            return;
        }
        
        startDate = dateRange.startDate.format('YYYY-MM-DD');
        endDate = dateRange.endDate.format('YYYY-MM-DD');
        
        console.log('Applying filters with:', { 
            startDate, 
            endDate, 
            modelFilter: modelFilter.value 
        });
        
        // Force clear any previous data
        updateSummaryStats({
            total_requests: 0,
            total_prompt_tokens: 0,
            total_completion_tokens: 0,
            total_tokens: 0,
            total_cost: 0,
            avg_cost_per_request: 0
        });
        
        tokenUsageChart.data.labels = [];
        tokenUsageChart.data.datasets[0].data = [];
        tokenUsageChart.data.datasets[1].data = [];
        tokenUsageChart.update();
        
        costChart.data.labels = [];
        costChart.data.datasets[0].data = [];
        costChart.update();
        
        tokenDistributionChart.data.datasets[0].data = [0, 0];
        tokenDistributionChart.update();
        
        costEfficiencyChart.data.labels = [];
        costEfficiencyChart.data.datasets[0].data = [];
        costEfficiencyChart.update();
        
        // Clear tables
        tableBody.innerHTML = '';
        highCostTableBody.innerHTML = '';
        
        // Load the filtered data
        loadData();
    });
    
    console.log('Enhanced event handlers set up successfully');
});

// Replace the loadData function to ensure model filtering works correctly
async function enhancedLoadData() {
    showLoading('Loading token usage data...');
    
    const modelSelection = modelFilter.value;
    
    const url = `/api/token-data?start_date=${startDate}&end_date=${endDate}&model=${encodeURIComponent(modelSelection)}`;
    console.log('Loading data with URL:', url);
    
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Server returned ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (data.success) {
            console.log('API data loaded successfully:', {
                modelDataCount: data.model_data.length,
                overallStats: data.overall_stats,
                dateDataCount: data.date_data.length,
                modelFilter: modelSelection
            });
            
            updateVisualizations(data);
            loadHighCostRecords();
        } else {
            hideLoading();
            showError('Failed to load data: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        hideLoading();
        console.error('Error loading data:', error);
        showError('Failed to load data: ' + error.message);
    }
}

// Enhanced loadHighCostRecords function
async function enhancedLoadHighCostRecords() {
    showLoading('Loading high-cost records...');
    
    const modelSelection = modelFilter.value;
    
    const url = `/api/sample-records?start_date=${startDate}&end_date=${endDate}&model=${encodeURIComponent(modelSelection)}`;
    console.log('Loading high-cost records with URL:', url);
    
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`Server returned ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        hideLoading();
        
        if (data.success) {
            console.log('Received high-cost records:', data.records.length);
            updateHighCostTable(data.records);
        } else {
            showError('Failed to load high-cost records: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        hideLoading();
        console.error('Error loading high-cost records:', error);
        showError('Failed to load high-cost records: ' + error.message);
    }
}

// Replace the original functions with our enhanced versions
window.addEventListener('load', function() {
    console.log('Applying model filter fixes');
    window.loadData = enhancedLoadData;
    window.loadHighCostRecords = enhancedLoadHighCostRecords;
});

</script>

<script>
// Complete replacement for the critical functions
// This bypasses any issues with function overriding or previous implementations

// Reset all visualizations and then reload data
function clearAndReloadData() {
    console.log('Clearing visualizations and reloading data');
    
    // Clear summary stats
    document.getElementById('totalRequests').textContent = '0';
    document.getElementById('totalTokens').textContent = '0';
    document.getElementById('totalCost').textContent = '$0.00';
    document.getElementById('avgCost').textContent = '$0.00';
    
    // Clear charts
    if (tokenUsageChart) {
        tokenUsageChart.data.labels = [];
        tokenUsageChart.data.datasets[0].data = [];
        tokenUsageChart.data.datasets[1].data = [];
        tokenUsageChart.update();
    }
    
    if (costChart) {
        costChart.data.labels = [];
        costChart.data.datasets[0].data = [];
        costChart.update();
    }
    
    if (tokenDistributionChart) {
        tokenDistributionChart.data.datasets[0].data = [0, 0];
        tokenDistributionChart.update();
    }
    
    if (costEfficiencyChart) {
        costEfficiencyChart.data.labels = [];
        costEfficiencyChart.data.datasets[0].data = [];
        costEfficiencyChart.update();
    }
    
    // Clear daily charts
    if (dailyTokenChart) {
        dailyTokenChart.data.labels = [];
        dailyTokenChart.data.datasets[0].data = [];
        dailyTokenChart.data.datasets[1].data = [];
        dailyTokenChart.update();
    }
    
    if (dailyCostChart) {
        dailyCostChart.data.labels = [];
        dailyCostChart.data.datasets[0].data = [];
        dailyCostChart.update();
    }
    
    if (dailyRequestChart) {
        dailyRequestChart.data.labels = [];
        dailyRequestChart.data.datasets[0].data = [];
        dailyRequestChart.update();
    }
    
    // Clear tables
    document.getElementById('tableBody').innerHTML = '';
    document.getElementById('highCostTableBody').innerHTML = '';
    
    // Reload data
    directLoadData();
}

// Direct implementation of loadData that doesn't rely on any previous version
async function directLoadData() {
    showLoading('Loading token usage data...');
    
    const modelFilter = document.getElementById('modelFilter');
    const dateRangePicker = document.getElementById('dateRangePicker');
    
    // Get model selection
    const modelSelection = modelFilter ? modelFilter.value : 'all';
    
    // Get date range
    let startDate, endDate;
    try {
        const dateRange = $(dateRangePicker).data('daterangepicker');
        startDate = dateRange.startDate.format('YYYY-MM-DD');
        endDate = dateRange.endDate.format('YYYY-MM-DD');
    } catch (error) {
        console.error('Error getting date range:', error);
        hideLoading();
        showError('Could not get date range. Please try refreshing the page.');
        return;
    }
    
    const url = `/api/token-data?start_date=${encodeURIComponent(startDate)}&end_date=${encodeURIComponent(endDate)}&model=${encodeURIComponent(modelSelection)}`;
    console.log('Loading data with URL:', url);
    
    try {
        // Make the API request
        const response = await fetch(url);
        const data = await response.json();
        
        console.log('API response:', data);
        
        if (data.success) {
            // Update visualizations with the new data
            directUpdateVisualizations(data);
            
            // Load high-cost records
            directLoadHighCostRecords();
        } else {
            hideLoading();
            showError('Failed to load data: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        hideLoading();
        console.error('Error loading data:', error);
        showError('Failed to load data: ' + error.message);
    }
}

// Direct implementation of updateVisualizations
function directUpdateVisualizations(data) {
    const modelData = data.model_data || [];
    const overallStats = data.overall_stats || {
        total_requests: 0,
        total_prompt_tokens: 0,
        total_completion_tokens: 0,
        total_tokens: 0,
        total_cost: 0,
        avg_cost_per_request: 0
    };
    const dateData = data.date_data || [];
    
    console.log('Updating visualizations with:', {
        modelData: modelData.length + ' records',
        overallStats,
        dateData: dateData.length + ' records'
    });
    
    // Update summary stats
    document.getElementById('totalRequests').textContent = formatNumber(overallStats.total_requests);
    document.getElementById('totalTokens').textContent = formatNumber(overallStats.total_tokens);
    document.getElementById('totalCost').textContent = formatCurrency(overallStats.total_cost);
    document.getElementById('avgCost').textContent = formatCurrency(overallStats.avg_cost_per_request);
    
    // Update token usage chart
    if (tokenUsageChart) {
        const models = modelData.map(item => {
            const parts = item.model.split('/');
            return parts.length > 1 ? parts[parts.length - 1] : item.model;
        });
        const promptTokens = modelData.map(item => item.prompt_tokens);
        const completionTokens = modelData.map(item => item.completion_tokens);
        
        tokenUsageChart.data.labels = models;
        tokenUsageChart.data.datasets[0].data = promptTokens;
        tokenUsageChart.data.datasets[1].data = completionTokens;
        tokenUsageChart.update();
    }
    
    // Update cost chart
    if (costChart) {
        const models = modelData.map(item => {
            const parts = item.model.split('/');
            return parts.length > 1 ? parts[parts.length - 1] : item.model;
        });
        const costs = modelData.map(item => item.total_cost);
        
        costChart.data.labels = models;
        costChart.data.datasets[0].data = costs;
        costChart.update();
    }
    
    // Update token distribution chart
    if (tokenDistributionChart) {
        tokenDistributionChart.data.datasets[0].data = [
            overallStats.total_prompt_tokens,
            overallStats.total_completion_tokens
        ];
        tokenDistributionChart.update();
    }
    
    // Update cost efficiency chart
    if (costEfficiencyChart) {
        const models = modelData.map(item => {
            const parts = item.model.split('/');
            return parts.length > 1 ? parts[parts.length - 1] : item.model;
        });
        const costPer1kTokens = modelData.map(item => item.cost_per_1k_tokens);
        
        costEfficiencyChart.data.labels = models;
        costEfficiencyChart.data.datasets[0].data = costPer1kTokens;
        costEfficiencyChart.update();
    }
    
    // Update daily charts
    if (dateData && dateData.length > 0) {
        // Update token chart
        if (dailyTokenChart) {
            const dates = dateData.map(item => item.date);
            const promptTokens = dateData.map(item => item.prompt_tokens);
            const completionTokens = dateData.map(item => item.completion_tokens);
            
            dailyTokenChart.data.labels = dates;
            dailyTokenChart.data.datasets[0].data = promptTokens;
            dailyTokenChart.data.datasets[1].data = completionTokens;
            dailyTokenChart.update();
        }
        
        // Update cost chart
        if (dailyCostChart) {
            const dates = dateData.map(item => item.date);
            const costs = dateData.map(item => item.total_cost);
            
            dailyCostChart.data.labels = dates;
            dailyCostChart.data.datasets[0].data = costs;
            dailyCostChart.update();
        }
        
        // Update request chart
        if (dailyRequestChart) {
            const dates = dateData.map(item => item.date);
            const requests = dateData.map(item => item.requests);
            
            dailyRequestChart.data.labels = dates;
            dailyRequestChart.data.datasets[0].data = requests;
            dailyRequestChart.update();
        }
    }
    
    // Update data table
    const tableBody = document.getElementById('tableBody');
    if (tableBody) {
        tableBody.innerHTML = '';
        
        modelData.forEach(item => {
            const row = document.createElement('tr');
            
            row.innerHTML = `
                <td>${item.model}</td>
                <td>${formatNumber(item.requests)}</td>
                <td>${formatNumber(item.prompt_tokens)}</td>
                <td>${formatNumber(item.completion_tokens)}</td>
                <td>${formatNumber(item.total_tokens)}</td>
                <td>${formatCurrency(item.total_cost)}</td>
                <td>${formatCurrency(item.avg_cost_per_request)}</td>
                <td>${formatCurrency(item.cost_per_1k_tokens)}</td>
            `;
            
            tableBody.appendChild(row);
        });
    }
    
    hideLoading();
}

// Direct implementation of loadHighCostRecords
async function directLoadHighCostRecords() {
    showLoading('Loading high-cost records...');
    
    const modelFilter = document.getElementById('modelFilter');
    const dateRangePicker = document.getElementById('dateRangePicker');
    
    // Get model selection
    const modelSelection = modelFilter ? modelFilter.value : 'all';
    
    // Get date range
    let startDate, endDate;
    try {
        const dateRange = $(dateRangePicker).data('daterangepicker');
        startDate = dateRange.startDate.format('YYYY-MM-DD');
        endDate = dateRange.endDate.format('YYYY-MM-DD');
    } catch (error) {
        console.error('Error getting date range:', error);
        hideLoading();
        showError('Could not get date range. Please try refreshing the page.');
        return;
    }
    
    const url = `/api/sample-records?start_date=${encodeURIComponent(startDate)}&end_date=${encodeURIComponent(endDate)}&model=${encodeURIComponent(modelSelection)}`;
    console.log('Loading high-cost records with URL:', url);
    
    try {
        const response = await fetch(url);
        const data = await response.json();
        
        hideLoading();
        
        if (data.success) {
            const records = data.records || [];
            console.log('Received high-cost records:', records.length);
            
            // Update high cost table
            const highCostTableBody = document.getElementById('highCostTableBody');
            if (highCostTableBody) {
                highCostTableBody.innerHTML = '';
                
                records.forEach(item => {
                    const row = document.createElement('tr');
                    
                    row.innerHTML = `
                        <td>${item.id}</td>
                        <td>${item.model}</td>
                        <td>${formatNumber(item.prompt_tokens)}</td>
                        <td>${formatNumber(item.completion_tokens)}</td>
                        <td>${formatNumber(item.total_tokens)}</td>
                        <td>${formatCurrency(item.cost)}</td>
                        <td>${item.datetime}</td>
                    `;
                    
                    highCostTableBody.appendChild(row);
                });
            }
        } else {
            showError('Failed to load high-cost records: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        hideLoading();
        console.error('Error loading high-cost records:', error);
        showError('Failed to load high-cost records: ' + error.message);
    }
}

// Format helpers (in case they're not working correctly elsewhere)
function formatNumber(num) {
    return new Intl.NumberFormat().format(Math.round(num || 0));
}

function formatCurrency(num) {
    return '$' + (num || 0).toFixed(2);
}

// Setup filter event handler
document.addEventListener('DOMContentLoaded', function() {
    // Get references to UI elements
    const modelFilter = document.getElementById('modelFilter');
    const applyFiltersBtn = document.getElementById('applyFilters');
    
    if (!applyFiltersBtn) {
        console.error('Could not find Apply Filters button!');
        return;
    }
    
    console.log('Setting up completely new filter handler');
    
    // Replace the Apply Filters button with a clone to remove any existing handlers
    const newButton = applyFiltersBtn.cloneNode(true);
    applyFiltersBtn.parentNode.replaceChild(newButton, applyFiltersBtn);
    
    // Add a new click handler
    newButton.addEventListener('click', function(event) {
        event.preventDefault();
        console.log('Apply Filters button clicked (new handler)');
        clearAndReloadData();
    });
    
    console.log('New filter handler set up successfully');
});

// Clean startup
window.addEventListener('load', function() {
    console.log('Window loaded, setting up direct functions');
    window.originalLoadData = window.loadData;
    window.originalLoadHighCostRecords = window.loadHighCostRecords;
    
    // Replace the functions with our direct versions
    window.loadData = directLoadData;
    window.loadHighCostRecords = directLoadHighCostRecords;
    
    // Add a global diagnostic function
    window.fixFiltering = function() {
        console.log('Manual filter fix applied');
        clearAndReloadData();
    };
    
    // Start logging events
    console.log('Patched functions set up - use window.fixFiltering() to manually force refresh if needed');
});

</script>

<script src="model-filter-fix.js"></script>
</body> tag in index.html
// Enhanced error handling for API calls
function handleApiError(error, context) {
    console.error(`${context} error:`, error);
    let errorMsg = error.message || 'Unknown error';
    
    // Additional debugging information
    if (error.stack) {
        console.error('Stack trace:', error.stack);
    }
    
    // Show user-friendly error
    showError(`${context}: ${errorMsg}`);
    hideLoading();
}

// More robust fetch wrapper that handles network errors and JSON parsing
async function safeFetch(url, options = {}) {
    try {
        const response = await fetch(url, options);
        
        if (!response.ok) {
            throw new Error(`Server returned ${response.status}: ${response.statusText}`);
        }
        
        try {
            const data = await response.json();
            return data;
        } catch (jsonError) {
            throw new Error(`Failed to parse JSON response: ${jsonError.message}`);
        }
    } catch (fetchError) {
        throw new Error(`Network request failed: ${fetchError.message}`);
    }
}

// Check database connection on page load
async function checkDatabaseConnection() {
    try {
        const data = await safeFetch('/api/date-range');
        
        if (!data.success) {
            showError(`Database connection issue: ${data.error || 'Unknown error'}`);
            return false;
        }
        return true;
    } catch (error) {
        handleApiError(error, 'Database connection check');
        return false;
    }
}

// Update the date range picker initialization
async function initDateRangePicker() {
    showLoading('Checking database connection...');
    
    const dbConnected = await checkDatabaseConnection();
    
    if (!dbConnected) {
        hideLoading();
        showError('Could not connect to the database. Please check server logs.');
        return;
    }
    
    showLoading('Loading available date range...');
    
    try {
        const data = await safeFetch('/api/date-range');
        
        hideLoading();
        
        if (data.success) {
            // Use defaults if no min/max dates found
            const minDate = data.min_date ? moment(data.min_date) : moment().subtract(30, 'days');
            const maxDate = data.max_date ? moment(data.max_date) : moment();
            
            console.log('Database date range:', {minDate: minDate.format('YYYY-MM-DD'), maxDate: maxDate.format('YYYY-MM-DD')});
            
            // Set default selection to last 7 days or available range if shorter
            startDate = moment(maxDate).subtract(7, 'days').isBefore(minDate) 
                ? minDate.format('YYYY-MM-DD')
                : moment(maxDate).subtract(7, 'days').format('YYYY-MM-DD');
            endDate = maxDate.format('YYYY-MM-DD');
            
            // Initialize daterangepicker with more options
            $(dateRangePicker).daterangepicker({
                startDate: moment(startDate),
                endDate: moment(endDate),
                minDate: minDate,
                maxDate: maxDate,
                opens: 'left',
                autoApply: true,
                showDropdowns: true,
                alwaysShowCalendars: true,
                ranges: {
                   'Today': [moment(), moment()],
                   'Yesterday': [moment().subtract(1, 'days'), moment().subtract(1, 'days')],
                   'Last 7 Days': [moment().subtract(6, 'days'), moment()],
                   'Last 30 Days': [moment().subtract(29, 'days'), moment()],
                   'This Month': [moment().startOf('month'), moment().endOf('month')],
                   'Last Month': [moment().subtract(1, 'month').startOf('month'), moment().subtract(1, 'month').endOf('month')]
                },
                locale: {
                    format: 'YYYY-MM-DD'
                }
            }, function(start, end) {
                startDate = start.format('YYYY-MM-DD');
                endDate = end.format('YYYY-MM-DD');
                console.log('Date range selected:', {startDate, endDate});
            });
            
            // Load models
            loadModels();
        } else {
            showError('Failed to load date range: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        handleApiError(error, 'Date range initialization');
    }
}

// Update the loadModels function
async function loadModels() {
    showLoading('Loading models...');
    
    try {
        const data = await safeFetch('/api/models');
        
        hideLoading();
        
        if (data.success) {
            modelFilter.innerHTML = '<option value="all">All Models</option>';
            
            data.models.forEach(model => {
                const option = document.createElement('option');
                option.value = model;
                option.textContent = model;
                modelFilter.appendChild(option);
            });
            
            // Initial data load
            loadData();
        } else {
            showError('Failed to load models: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        handleApiError(error, 'Model loading');
    }
}

// Update the loadData function
async function loadData() {
    showLoading('Loading token usage data...');
    
    const modelSelection = modelFilter.value;
    
    const url = `/api/token-data?start_date=${startDate}&end_date=${endDate}&model=${modelSelection}`;
    console.log('Loading data with URL:', url);
    
    try {
        const data = await safeFetch(url);
        
        if (data.success) {
            console.log('API data loaded successfully:', {
                modelDataCount: data.model_data.length,
                overallStats: data.overall_stats,
                dateDataCount: data.date_data.length
            });
            
            updateVisualizations(data);
            loadHighCostRecords();
        } else {
            hideLoading();
            showError('Failed to load data: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        handleApiError(error, 'Data loading');
    }
}

// Update the loadHighCostRecords function
async function loadHighCostRecords() {
    showLoading('Loading high-cost records...');
    
    const modelSelection = modelFilter.value;
    
    const url = `/api/sample-records?start_date=${startDate}&end_date=${endDate}&model=${modelSelection}`;
    
    try {
        const data = await safeFetch(url);
        
        hideLoading();
        
        if (data.success) {
            updateHighCostTable(data.records);
        } else {
            showError('Failed to load high-cost records: ' + (data.error || 'Unknown error'));
        }
    } catch (error) {
        handleApiError(error, 'High-cost records loading');
    }
}

</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Dashboard</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- DateRangePicker -->
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.css" />
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .card {
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .card-header {
            background-color: #4a6fa5;
            color: white;
            font-weight: bold;
            border-radius: 8px 8px 0 0 !important;
        }
        .filters {
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .chart-container {
            height: 300px;
            position: relative;
        }
        .stat-card {
            text-align: center;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            background-color: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .stat-card h3 {
            font-size: 2.2rem;
            font-weight: bold;
            margin: 10px 0;
            color: #4a6fa5;
        }
        .stat-card p {
            font-size: 1.1rem;
            color: #6c757d;
            margin: 0;
        }
        table {
            font-size: 0.9rem;
        }
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .loading-content {
            text-align: center;
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        .spinner-border {
            width: 3rem;
            height: 3rem;
        }
        .daterangepicker {
            z-index: 10000 !important;
        }
        .daily-chart-container {
            height: 400px;
            position: relative;
            margin-bottom: 30px;
        }
        .nav-pills .nav-link.active {
            background-color: #4a6fa5;
        }
        #errorAlert {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            max-width: 400px;
        }
    </style>
</head>
<body>
<script>
// Add console inspector for network requests
(function() {
    console.log('%cðŸ” Request Inspector Activated', 'background: #222; color: #bada55; font-size: 16px; padding: 5px;');
    
    // Monitor fetch calls
    const originalFetch = window.fetch;
    window.fetch = async function() {
        console.log('%câ†’ Fetch Request', 'color: #2196F3; font-weight: bold;', {
            url: arguments[0],
            options: arguments[1]
        });
        
        try {
            const response = await originalFetch.apply(this, arguments);
            
            // Clone the response so we can log it and still return a usable response
            const clone = response.clone();
            
            // Log response status
            console.log('%câ† Fetch Response', 'color: #4CAF50; font-weight: bold;', {
                url: arguments[0],
                status: clone.status,
                statusText: clone.statusText
            });
            
            // Try to log the JSON response if possible
            try {
                const jsonResponse = await clone.json();
                console.log('%câ† Response Data', 'color: #FF9800;', jsonResponse);
            } catch (e) {
                console.log('%câ† Response is not JSON', 'color: #f44336;');
            }
            
            return response;
        } catch (error) {
            console.error('%câœ– Fetch Error', 'color: #f44336; font-weight: bold;', error);
            throw error;
        }
    };
    
    // Add visualization debugging
    const originalUpdate = Chart.prototype.update;
    Chart.prototype.update = function() {
        console.log('%cðŸ“Š Chart Update', 'color: #9c27b0; font-weight: bold;', {
            id: this.canvas.id,
            data: JSON.parse(JSON.stringify(this.data)), // Deep copy to avoid circular references
            options: this.options
        });
        return originalUpdate.apply(this, arguments);
    };
    
    // Create a debugger object for direct inspection
    window.debugger = {
        checkState: function() {
            console.log('%cðŸ“Œ Current State', 'background: #222; color: #bada55;', {
                dateRange: $(dateRangePicker).data('daterangepicker') ? {
                    startDate: $(dateRangePicker).data('daterangepicker').startDate.format('YYYY-MM-DD'),
                    endDate: $(dateRangePicker).data('daterangepicker').endDate.format('YYYY-MM-DD')
                } : 'Not Initialized',
                selectedModel: $('#modelFilter').val(),
                charts: {
                    tokenUsage: tokenUsageChart ? {
                        labels: tokenUsageChart.data.labels,
                        datasets: tokenUsageChart.data.datasets
                    } : 'Not Initialized',
                    // Add other charts as needed
                }
            });
        },
        testAPI: async function(model = 'all') {
            const dateRange = $(dateRangePicker).data('daterangepicker');
            if (!dateRange) {
                console.error('Date range picker not initialized');
                return;
            }
            
            const startDate = dateRange.startDate.format('YYYY-MM-DD');
            const endDate = dateRange.endDate.format('YYYY-MM-DD');
            
            console.log('%cðŸ§ª Manual API Test', 'background: #222; color: #bada55;', {
                startDate,
                endDate,
                model
            });
            
            try {
                const url = `/api/token-data?start_date=${startDate}&end_date=${endDate}&model=${encodeURIComponent(model)}`;
                const response = await fetch(url);
                const data = await response.json();
                
                console.log('%cðŸ§ª API Test Result', 'background: #222; color: #bada55;', data);
                return data;
            } catch (error) {
                console.error('%cðŸ§ª API Test Error', 'background: #222; color: #f44336;', error);
                return null;
            }
        },
        reinitialize: function() {
            console.log('%cðŸ”„ Reinitializing Filters', 'background: #222; color: #bada55;');
            
            // Reinitialize date range picker
            initDateRangePicker();
            
            // Force reload data
            setTimeout(() => {
                loadData();
            }, 1000);
        }
    };
    
    // Add to window object
    window.inspector = {
        logVisualizations: function() {
            if (tokenUsageChart) {
                console.log('Token Usage Chart:', tokenUsageChart.data);
            }
            if (costChart) {
                console.log('Cost Chart:', costChart.data);
            }
            if (tokenDistributionChart) {
                console.log('Token Distribution Chart:', tokenDistributionChart.data);
            }
            if (costEfficiencyChart) {
                console.log('Cost Efficiency Chart:', costEfficiencyChart.data);
            }
        }
    };
    
    console.log('%cðŸ’¡ Type "debugger.checkState()" to see current state', 'color: #2196F3;');
    console.log('%cðŸ’¡ Type "debugger.testAPI()" to manually test the API', 'color: #2196F3;');
    console.log('%cðŸ’¡ Type "inspector.logVisualizations()" to inspect charts', 'color: #2196F3;');
})();

</script>

    <div class="container-fluid">
        <!-- Header -->
        <div class="row mb-4">
            <div class="col-12">
                <h1 class="text-center text-primary">LLM Dashboard</h1>
                <p class="text-center text-muted">Dynamic analysis of token usage and costs across different models</p>
            </div>
        </div>

        <!-- Filters -->
        <div class="row filters">
            <div class="col-md-5 mb-3">
                <label for="dateRangePicker" class="form-label">Date Range</label>
                <input type="text" class="form-control" id="dateRangePicker" placeholder="Select date range">
            </div>
            <div class="col-md-4 mb-3">
                <label for="modelFilter" class="form-label">Model</label>
                <select class="form-select" id="modelFilter">
                    <option value="all">All Models</option>
                    <!-- Models will be dynamically populated -->
                </select>
            </div>
            <div class="col-md-3 mb-3 d-flex align-items-end">
                <button class="btn btn-primary w-100" id="applyFilters">Apply Filters</button>
            </div>
        </div>

        <!-- Summary Stats -->
        <div class="row mb-4">
            <div class="col-md-3">
                <div class="stat-card">
                    <p>Total Requests</p>
                    <h3 id="totalRequests">0</h3>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stat-card">
                    <p>Total Tokens</p>
                    <h3 id="totalTokens">0</h3>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stat-card">
                    <p>Total Cost</p>
                    <h3 id="totalCost">$0.00</h3>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stat-card">
                    <p>Avg. Cost per Request</p>
                    <h3 id="avgCost">$0.00</h3>
                </div>
            </div>
        </div>

        <!-- Daily Trends Chart -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">Daily Trends</div>
                    <div class="card-body">
                        <ul class="nav nav-pills mb-3" id="dailyChartTab" role="tablist">
                            <li class="nav-item" role="presentation">
                                <button class="nav-link active" id="tokens-tab" data-bs-toggle="pill" data-bs-target="#tokens" type="button" role="tab" aria-controls="tokens" aria-selected="true">Token Usage</button>
                            </li>
                            <li class="nav-item" role="presentation">
                                <button class="nav-link" id="costs-tab" data-bs-toggle="pill" data-bs-target="#costs" type="button" role="tab" aria-controls="costs" aria-selected="false">Costs</button>
                            </li>
                            <li class="nav-item" role="presentation">
                                <button class="nav-link" id="requests-tab" data-bs-toggle="pill" data-bs-target="#requests" type="button" role="tab" aria-controls="requests" aria-selected="false">Requests</button>
                            </li>
                        </ul>
                        <div class="tab-content" id="dailyChartTabContent">
                            <div class="tab-pane fade show active" id="tokens" role="tabpanel" aria-labelledby="tokens-tab">
                                <div class="daily-chart-container">
                                    <canvas id="dailyTokenChart"></canvas>
                                </div>
                            </div>
                            <div class="tab-pane fade" id="costs" role="tabpanel" aria-labelledby="costs-tab">
                                <div class="daily-chart-container">
                                    <canvas id="dailyCostChart"></canvas>
                                </div>
                            </div>
                            <div class="tab-pane fade" id="requests" role="tabpanel" aria-labelledby="requests-tab">
                                <div class="daily-chart-container">
                                    <canvas id="dailyRequestChart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Charts -->
        <div class="row">
            <!-- Token Usage by Model -->
            <div class="col-md-6 mb-4">
                <div class="card">
                    <div class="card-header">Token Usage by Model</div>
                    <div class="card-body">
                        <div class="chart-container">
                            <canvas id="tokenUsageChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Cost by Model -->
            <div class="col-md-6 mb-4">
                <div class="card">
                    <div class="card-header">Cost by Model</div>
                    <div class="card-body">
                        <div class="chart-container">
                            <canvas id="costChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Token Distribution -->
            <div class="col-md-6 mb-4">
                <div class="card">
                    <div class="card-header">Token Distribution (Prompt vs Completion)</div>
                    <div class="card-body">
                        <div class="chart-container">
                            <canvas id="tokenDistributionChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Cost Efficiency -->
            <div class="col-md-6 mb-4">
                <div class="card">
                    <div class="card-header">Cost per 1K Tokens by Model</div>
                    <div class="card-body">
                        <div class="chart-container">
                            <canvas id="costEfficiencyChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- High Cost Requests -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">Top 10 Highest Cost Requests</div>
                    <div class="card-body">
                        <div class="table-responsive">
                            <table class="table table-striped table-hover" id="highCostTable">
                                <thead>
                                    <tr>
                                        <th>ID</th>
                                        <th>Model</th>
                                        <th>Prompt Tokens</th>
                                        <th>Completion Tokens</th>
                                        <th>Total Tokens</th>
                                        <th>Cost ($)</th>
                                        <th>Date & Time</th>
                                    </tr>
                                </thead>
                                <tbody id="highCostTableBody">
                                    <!-- Table data will be dynamically populated -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Data Table -->
        <div class="row">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">Model Summary</div>
                    <div class="card-body">
                        <div class="table-responsive">
                            <table class="table table-striped table-hover" id="dataTable">
                                <thead>
                                    <tr>
                                        <th>Model</th>
                                        <th>Requests</th>
                                        <th>Prompt Tokens</th>
                                        <th>Completion Tokens</th>
                                        <th>Total Tokens</th>
                                        <th>Total Cost ($)</th>
                                        <th>Avg Cost/Request ($)</th>
                                        <th>Cost per 1K Tokens ($)</th>
                                    </tr>
                                </thead>
                                <tbody id="tableBody">
                                    <!-- Table data will be dynamically populated -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Error Alert -->
    <div class="alert alert-danger alert-dismissible fade" role="alert" id="errorAlert">
        <div id="errorMessage"></div>
        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    </div>

    <!-- Loading Overlay -->
    <div class="loading" id="loadingOverlay">
        <div class="loading-content">
            <div class="spinner-border text-primary mb-3" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <h5 id="loadingMessage">Loading Data...</h5>
        </div>
    </div>

    <!-- Bootstrap Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <!-- jQuery (required for DateRangePicker) -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <!-- Moment.js (required for DateRangePicker) -->
    <script src="https://cdn.jsdelivr.net/momentjs/latest/moment.min.js"></script>
    <!-- DateRangePicker -->
    <script src="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.min.js"></script>
    
    <script>
        // Charts instances (declare globally)
        let tokenUsageChart, costChart, tokenDistributionChart, costEfficiencyChart;
        let dailyTokenChart, dailyCostChart, dailyRequestChart;
        
        // DOM elements (declare globally)
        let dateRangePicker, modelFilter, applyFiltersBtn, loadingOverlay, loadingMessage, errorAlert, errorMessage;
        let totalRequestsEl, totalTokensEl, totalCostEl, avgCostEl;
        let tableBody, highCostTableBody;
        
        // Date range for filtering (declare globally)
        let startDate = moment().subtract(7, 'days').format('YYYY-MM-DD');
        let endDate = moment().format('YYYY-MM-DD');

        // Initialize Charts (Keep this definition here)
        function initCharts() {
            // Get references to DOM elements inside the function after DOM is loaded
            const tokenUsageCanvas = document.getElementById('tokenUsageChart');
            const costCanvas = document.getElementById('costChart');
            const tokenDistributionCanvas = document.getElementById('tokenDistributionChart');
            const costEfficiencyCanvas = document.getElementById('costEfficiencyChart');
            const dailyTokenCanvas = document.getElementById('dailyTokenChart');
            const dailyCostCanvas = document.getElementById('dailyCostChart');
            const dailyRequestCanvas = document.getElementById('dailyRequestChart');

            // Check if canvas elements exist before creating charts
            if (tokenUsageCanvas) {
                tokenUsageChart = new Chart(tokenUsageCanvas, {
                    type: 'bar',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'Prompt Tokens',
                                backgroundColor: '#4a6fa5',
                                data: []
                            },
                            {
                                label: 'Completion Tokens',
                                backgroundColor: '#ff9642',
                                data: []
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Token Usage by Model'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            label += new Intl.NumberFormat().format(context.parsed.y);
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                stacked: true,
                                title: {
                                    display: true,
                                    text: 'Model'
                                }
                            },
                            y: {
                                stacked: true,
                                title: {
                                    display: true,
                                    text: 'Number of Tokens'
                                },
                                ticks: {
                                    callback: function(value) {
                                        return new Intl.NumberFormat().format(value);
                                    }
                                }
                            }
                        }
                    }
                });
            } else { console.error("Canvas element 'tokenUsageChart' not found."); }

            if (costCanvas) {
                costChart = new Chart(costCanvas, {
                    type: 'bar',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Total Cost ($)',
                            backgroundColor: '#2ca02c',
                            data: []
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Cost by Model'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': $';
                                        }
                                        if (context.parsed.y !== null) {
                                            label += context.parsed.y.toFixed(2);
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                title: {
                                    display: true,
                                    text: 'Cost ($)'
                                },
                                ticks: {
                                    callback: function(value) {
                                        return '$' + value.toFixed(2);
                                    }
                                }
                            }
                        }
                    }
                });
            } else { console.error("Canvas element 'costChart' not found."); }

            if (tokenDistributionCanvas) {
                tokenDistributionChart = new Chart(tokenDistributionCanvas, {
                    type: 'pie',
                    data: {
                        labels: ['Prompt Tokens', 'Completion Tokens'],
                        datasets: [{
                            label: 'Tokens',
                            backgroundColor: ['#4a6fa5', '#ff9642'],
                            data: [0, 0]
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Token Distribution'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const label = context.label || '';
                                        const value = context.raw;
                                        const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                                        const percentage = Math.round((value / total) * 100);
                                        return `${label}: ${new Intl.NumberFormat().format(value)} (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
            } else { console.error("Canvas element 'tokenDistributionChart' not found."); }

            if (costEfficiencyCanvas) {
                costEfficiencyChart = new Chart(costEfficiencyCanvas, {
                    type: 'bar',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Cost per 1K Tokens ($)',
                            backgroundColor: '#d62728',
                            data: []
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Cost per 1K Tokens by Model'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': $';
                                        }
                                        if (context.parsed.y !== null) {
                                            label += context.parsed.y.toFixed(6);
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                title: {
                                    display: true,
                                    text: 'Cost per 1K Tokens ($)'
                                },
                                ticks: {
                                    callback: function(value) {
                                        return '$' + value.toFixed(6);
                                    }
                                }
                            }
                        }
                    }
                });
            } else { console.error("Canvas element 'costEfficiencyChart' not found."); }

            if (dailyTokenCanvas) {
                dailyTokenChart = new Chart(dailyTokenCanvas, {
                    type: 'bar',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'Prompt Tokens',
                                backgroundColor: '#4a6fa5',
                                data: [],
                                order: 1
                            },
                            {
                                label: 'Completion Tokens',
                                backgroundColor: '#ff9642',
                                data: [],
                                order: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Daily Token Usage'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed.y !== null) {
                                            label += new Intl.NumberFormat().format(context.parsed.y);
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                stacked: true,
                                title: {
                                    display: true,
                                    text: 'Date'
                                }
                            },
                            y: {
                                stacked: true,
                                title: {
                                    display: true,
                                    text: 'Number of Tokens'
                                },
                                ticks: {
                                    callback: function(value) {
                                        return new Intl.NumberFormat().format(value);
                                    }
                                }
                            }
                        }
                    }
                });
            } else { console.error("Canvas element 'dailyTokenChart' not found."); }

            if (dailyCostCanvas) {
                dailyCostChart = new Chart(dailyCostCanvas, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Total Cost ($)',
                            borderColor: '#2ca02c',
                            backgroundColor: 'rgba(44, 160, 44, 0.2)',
                            data: [],
                            tension: 0.1,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Daily Cost'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) {
                                            label += ': $';
                                        }
                                        if (context.parsed.y !== null) {
                                            label += context.parsed.y.toFixed(2);
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                title: {
                                    display: true,
                                    text: 'Cost ($)'
                                },
                                ticks: {
                                    callback: function(value) {
                                        return '$' + value.toFixed(2);
                                    }
                                }
                            }
                        }
                    }
                });
            } else { console.error("Canvas element 'dailyCostChart' not found."); }

            if (dailyRequestCanvas) {
                dailyRequestChart = new Chart(dailyRequestCanvas, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Number of Requests',
                            borderColor: '#9467bd',
                            backgroundColor: 'rgba(148, 103, 189, 0.2)',
                            data: [],
                            tension: 0.1,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Daily Requests'
                            }
                        },
                        scales: {
                            y: {
                                title: {
                                    display: true,
                                    text: 'Number of Requests'
                                },
                                beginAtZero: true
                            }
                        }
                    }
                });
            } else { console.error("Canvas element 'dailyRequestChart' not found."); }
        }

        // Format numbers for display
        function formatNumber(num) {
            // Handle null/undefined/NaN safely
            const number = Number(num);
            return isNaN(number) ? '0' : new Intl.NumberFormat().format(Math.round(number));
        }

        function formatCurrency(num) {
            // Handle null/undefined/NaN safely
            const number = Number(num);
            return isNaN(number) ? '$0.00' : '$' + number.toFixed(2);
        }

        // Update summary stats
        function updateSummaryStats(stats) {
            if (!stats) return; // Add safety check
            totalRequestsEl.textContent = formatNumber(stats.total_requests);
            totalTokensEl.textContent = formatNumber(stats.total_tokens);
            totalCostEl.textContent = formatCurrency(stats.total_cost);
            avgCostEl.textContent = formatCurrency(stats.avg_cost_per_request);
        }

        // Update token usage chart
        function updateTokenUsageChart(data) {
            if (!tokenUsageChart || !data) return; // Add safety check
            const models = data.map(item => {
                const parts = item.model.split('/');
                return parts.length > 1 ? parts[parts.length - 1] : item.model;
            });
            const promptTokens = data.map(item => item.prompt_tokens);
            const completionTokens = data.map(item => item.completion_tokens);
            
            tokenUsageChart.data.labels = models;
            tokenUsageChart.data.datasets[0].data = promptTokens;
            tokenUsageChart.data.datasets[1].data = completionTokens;
            tokenUsageChart.update();
        }

        // Update cost chart
        function updateCostChart(data) {
            if (!costChart || !data) return; // Add safety check
            const models = data.map(item => {
                const parts = item.model.split('/');
                return parts.length > 1 ? parts[parts.length - 1] : item.model;
            });
            const costs = data.map(item => item.total_cost);
            
            costChart.data.labels = models;
            costChart.data.datasets[0].data = costs;
            costChart.update();
        }

        // Update token distribution chart
        function updateTokenDistributionChart(stats) {
            if (!tokenDistributionChart || !stats) return; // Add safety check
            tokenDistributionChart.data.datasets[0].data = [
                stats.total_prompt_tokens || 0, // Add default values
                stats.total_completion_tokens || 0
            ];
            tokenDistributionChart.update();
        }

        // Update cost efficiency chart
        function updateCostEfficiencyChart(data) {
            if (!costEfficiencyChart || !data) return; // Add safety check
            const models = data.map(item => {
                const parts = item.model.split('/');
                return parts.length > 1 ? parts[parts.length - 1] : item.model;
            });
            const costPer1kTokens = data.map(item => item.cost_per_1k_tokens);
            
            costEfficiencyChart.data.labels = models;
            costEfficiencyChart.data.datasets[0].data = costPer1kTokens;
            costEfficiencyChart.update();
        }

        // Update daily charts
        function updateDailyCharts(data) {
            if (!data || data.length === 0) return; // Add safety check
            const dates = data.map(item => item.date);
            const promptTokens = data.map(item => item.prompt_tokens);
            const completionTokens = data.map(item => item.completion_tokens);
            const costs = data.map(item => item.total_cost);
            const requests = data.map(item => item.requests);
            
            // Update token chart
            if (dailyTokenChart) {
                dailyTokenChart.data.labels = dates;
                dailyTokenChart.data.datasets[0].data = promptTokens;
                dailyTokenChart.data.datasets[1].data = completionTokens;
                dailyTokenChart.update();
            }
            
            // Update cost chart
            if (dailyCostChart) {
                dailyCostChart.data.labels = dates;
                dailyCostChart.data.datasets[0].data = costs;
                dailyCostChart.update();
            }
            
            // Update request chart
            if (dailyRequestChart) {
                dailyRequestChart.data.labels = dates;
                dailyRequestChart.data.datasets[0].data = requests;
                dailyRequestChart.update();
            }
        }

        // Update data table
        function updateDataTable(data) {
            if (!tableBody || !data) return; // Add safety check
            tableBody.innerHTML = '';
            
            data.forEach(item => {
                const row = document.createElement('tr');
                
                row.innerHTML = `
                    <td>${item.model || 'N/A'}</td>
                    <td>${formatNumber(item.requests)}</td>
                    <td>${formatNumber(item.prompt_tokens)}</td>
                    <td>${formatNumber(item.completion_tokens)}</td>
                    <td>${formatNumber(item.total_tokens)}</td>
                    <td>${formatCurrency(item.total_cost)}</td>
                    <td>${formatCurrency(item.avg_cost_per_request)}</td>
                    <td>${formatCurrency(item.cost_per_1k_tokens)}</td>
                `;
                
                tableBody.appendChild(row);
            });
        }

        // Update high cost table
        function updateHighCostTable(data) {
            if (!highCostTableBody || !data) return; // Add safety check
            highCostTableBody.innerHTML = '';
            
            data.forEach(item => {
                const row = document.createElement('tr');
                
                row.innerHTML = `
                    <td>${item.id || 'N/A'}</td>
                    <td>${item.model || 'N/A'}</td>
                    <td>${formatNumber(item.prompt_tokens)}</td>
                    <td>${formatNumber(item.completion_tokens)}</td>
                    <td>${formatNumber(item.total_tokens)}</td>
                    <td>${formatCurrency(item.cost)}</td>
                    <td>${item.datetime || 'N/A'}</td>
                `;
                
                highCostTableBody.appendChild(row);
            });
        }

        // Update all visualizations
        function updateVisualizations(data) {
            if (!data) return; // Add safety check
            const modelData = data.model_data || [];
            const overallStats = data.overall_stats || {};
            const dateData = data.date_data || [];
            
            updateSummaryStats(overallStats);
            updateTokenUsageChart(modelData);
            updateCostChart(modelData);
            updateTokenDistributionChart(overallStats);
            updateCostEfficiencyChart(modelData);
            updateDataTable(modelData);
            updateDailyCharts(dateData);
        }

        // Show loading overlay
        function showLoading(message = 'Loading...') {
            if (!loadingOverlay || !loadingMessage) return; // Add safety check
            loadingMessage.textContent = message;
            loadingOverlay.style.display = 'flex';
        }

        // Hide loading overlay
        function hideLoading() {
            if (!loadingOverlay) return; // Add safety check
            loadingOverlay.style.display = 'none';
        }

        // Show error message
        function showError(message) {
            if (!errorAlert || !errorMessage) return; // Add safety check
            errorMessage.textContent = message;
            // Use Bootstrap's API to show the alert if available, otherwise fallback
            const bsAlert = bootstrap.Alert.getInstance(errorAlert);
            if (bsAlert) {
                // If it's already shown, just update text. If not, need to re-enable it.
                // This part is tricky as Bootstrap removes the element on close.
                // A simpler approach might be to just ensure it's visible.
                errorAlert.classList.add('show');
                errorAlert.style.display = 'block'; // Ensure visibility
            } else {
                 // If bootstrap isn't initialized on it, manually show
                 errorAlert.classList.add('show');
                 errorAlert.style.display = 'block';
                 // Initialize Bootstrap alert for the close button to work
                 new bootstrap.Alert(errorAlert);
            }

            // Auto-hide after 5 seconds
            setTimeout(() => {
                const currentBsAlert = bootstrap.Alert.getInstance(errorAlert);
                if (currentBsAlert) {
                    currentBsAlert.close();
                } else {
                    errorAlert.classList.remove('show');
                    errorAlert.style.display = 'none';
                }
            }, 5000);
        }

        // Enhanced error handling for API calls
        function handleApiError(error, context) {
            console.error(`${context} error:`, error);
            let errorMsg = error.message || 'Unknown error';
            
            // Additional debugging information
            if (error.stack) {
                console.error('Stack trace:', error.stack);
            }
            
            // Show user-friendly error
            showError(`${context}: ${errorMsg}`);
            hideLoading(); // Ensure loading is hidden on error
        }

        // More robust fetch wrapper that handles network errors and JSON parsing
        async function safeFetch(url, options = {}) {
            try {
                const response = await fetch(url, options);
                
                if (!response.ok) {
                    // Try to get error message from response body
                    let serverErrorMsg = '';
                    try {
                        const errorData = await response.json();
                        serverErrorMsg = errorData.error || JSON.stringify(errorData);
                    } catch (e) {
                        serverErrorMsg = await response.text();
                    }
                    throw new Error(`Server returned ${response.status}: ${response.statusText}. ${serverErrorMsg}`);
                }
                
                try {
                    const data = await response.json();
                    return data;
                } catch (jsonError) {
                    throw new Error(`Failed to parse JSON response: ${jsonError.message}`);
                }
            } catch (fetchError) {
                // Catch network errors or errors thrown above
                throw new Error(`Request failed: ${fetchError.message}`);
            }
        }

        // Check database connection on page load
        async function checkDatabaseConnection() {
            try {
                // Use date-range endpoint as a proxy for DB connection check
                const data = await safeFetch('/api/date-range');
                
                if (!data.success) {
                    // Use the error from the API response if available
                    showError(`Database connection issue: ${data.error || 'Could not verify connection'}`);
                    return false;
                }
                console.log('Database connection check successful.');
                return true;
            } catch (error) {
                // safeFetch will throw an error for network issues or bad responses
                handleApiError(error, 'Database connection check');
                return false;
            }
        }

        // Definitive Date Range Picker Initialization
        async function initDateRangePicker() {
            showLoading('Checking database connection...');
            
            const dbConnected = await checkDatabaseConnection();
            
            if (!dbConnected) {
                hideLoading();
                // Error message already shown by checkDatabaseConnection
                return;
            }
            
            showLoading('Loading available date range...');
            
            try {
                const data = await safeFetch('/api/date-range');
                hideLoading(); // Hide loading after fetch attempt
                
                if (data.success) {
                    // Use defaults if no min/max dates found, or if they are invalid
                    const minDateMoment = data.min_date ? moment(data.min_date) : moment().subtract(30, 'days');
                    const maxDateMoment = data.max_date ? moment(data.max_date) : moment();

                    // Validate moments
                    const minDate = minDateMoment.isValid() ? minDateMoment : moment().subtract(30, 'days');
                    const maxDate = maxDateMoment.isValid() ? maxDateMoment : moment();

                    console.log('Database date range:', {minDate: minDate.format('YYYY-MM-DD'), maxDate: maxDate.format('YYYY-MM-DD')});
                    
                    // Set default selection to last 7 days or available range if shorter
                    // Ensure start date is not after end date
                    let defaultStartDate = moment(maxDate).subtract(6, 'days'); // 7 days including today
                    if (defaultStartDate.isBefore(minDate)) {
                        defaultStartDate = minDate;
                    }
                    
                    startDate = defaultStartDate.format('YYYY-MM-DD');
                    endDate = maxDate.format('YYYY-MM-DD');
                    
                    // Initialize daterangepicker with more options
                    $(dateRangePicker).daterangepicker({
                        startDate: defaultStartDate, // Use moment object
                        endDate: maxDate,       // Use moment object
                        minDate: minDate,
                        maxDate: maxDate,
                        opens: 'left',
                        autoApply: true,
                        showDropdowns: true,
                        alwaysShowCalendars: true,
                        ranges: {
                           'Today': [moment(), moment()],
                           'Yesterday': [moment().subtract(1, 'days'), moment().subtract(1, 'days')],
                           'Last 7 Days': [moment().subtract(6, 'days'), moment()],
                           'Last 30 Days': [moment().subtract(29, 'days'), moment()],
                           'This Month': [moment().startOf('month'), moment().endOf('month')],
                           'Last Month': [moment().subtract(1, 'month').startOf('month'), moment().subtract(1, 'month').endOf('month')]
                        },
                        locale: {
                            format: 'YYYY-MM-DD'
                        }
                    }, function(start, end) {
                        // Update global variables when selection changes
                        startDate = start.format('YYYY-MM-DD');
                        endDate = end.format('YYYY-MM-DD');
                        console.log('Date range selected:', {startDate, endDate});
                        // Optionally trigger data load on change, or rely on Apply button
                        // loadData(); // Uncomment if you want auto-refresh on date change
                    });
                    
                    // Load models after date picker is ready
                    loadModels();
                } else {
                    showError('Failed to load date range: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                handleApiError(error, 'Date range initialization');
            }
        }

        // Definitive Load Models function
        async function loadModels() {
            showLoading('Loading models...');
            
            try {
                const data = await safeFetch('/api/models');
                hideLoading(); // Hide loading after fetch attempt
                
                if (data.success && data.models) {
                    modelFilter.innerHTML = '<option value="all">All Models</option>'; // Reset options
                    
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model;
                        option.textContent = model;
                        modelFilter.appendChild(option);
                    });
                    
                    // Initial data load now that models and date range are ready
                    loadData();
                } else {
                    showError('Failed to load models: ' + (data.error || 'No models found'));
                }
            } catch (error) {
                handleApiError(error, 'Model loading');
            }
        }

        // Definitive Load Data function
        async function loadData() {
            showLoading('Loading token usage data...');
            
            // Ensure modelFilter has a value, default to 'all' if not
            const modelSelection = modelFilter ? modelFilter.value : 'all';
            
            // Ensure dates are valid
            if (!startDate || !endDate) {
                 showError('Invalid date range selected.');
                 hideLoading();
                 return;
            }

            const url = `/api/token-data?start_date=${encodeURIComponent(startDate)}&end_date=${encodeURIComponent(endDate)}&model=${encodeURIComponent(modelSelection)}`;
            console.log('Loading data with URL:', url);
            
            try {
                const data = await safeFetch(url);
                
                if (data.success) {
                    console.log('API data loaded successfully:', {
                        modelDataCount: data.model_data ? data.model_data.length : 0,
                        overallStats: data.overall_stats,
                        dateDataCount: data.date_data ? data.date_data.length : 0
                    });
                    
                    // Update visualizations with potentially empty data if API returns success but no data
                    updateVisualizations(data);
                    
                    // Load high cost records after main data is processed
                    loadHighCostRecords(); // This will call hideLoading() when done
                } else {
                    hideLoading(); // Hide loading if success is false
                    showError('Failed to load data: ' + (data.error || 'Unknown error'));
                    // Clear visualizations on data load failure? Optional.
                    // updateVisualizations({ model_data: [], overall_stats: {}, date_data: [] });
                }
            } catch (error) {
                // safeFetch handles error reporting via handleApiError
                handleApiError(error, 'Data loading');
                // Clear visualizations on critical error? Optional.
                // updateVisualizations({ model_data: [], overall_stats: {}, date_data: [] });
            }
        }

        // Definitive Load High Cost Records function
        async function loadHighCostRecords() {
            // Don't show separate loading message, assume it's part of main loadData flow
            // showLoading('Loading high-cost records...'); 
            
            const modelSelection = modelFilter ? modelFilter.value : 'all';
            
            // Ensure dates are valid
            if (!startDate || !endDate) {
                 console.warn('Skipping high-cost records load due to invalid date range.');
                 hideLoading(); // Ensure loading is hidden if we skip
                 return;
            }

            const url = `/api/sample-records?start_date=${encodeURIComponent(startDate)}&end_date=${encodeURIComponent(endDate)}&model=${encodeURIComponent(modelSelection)}`;
            console.log('Loading high-cost records with URL:', url);

            try {
                const data = await safeFetch(url);
                hideLoading(); // Hide loading after this final fetch in the sequence
                
                if (data.success && data.records) {
                    updateHighCostTable(data.records);
                } else {
                    // Don't necessarily show an error if high-cost records fail, could be less critical
                    console.warn('Failed to load high-cost records: ' + (data.error || 'No records found or error'));
                    updateHighCostTable([]); // Clear the table on failure
                }
            } catch (error) {
                hideLoading(); // Ensure loading is hidden on error
                // Don't necessarily show a blocking error, just log it
                console.error('High-cost records loading error:', error);
                updateHighCostTable([]); // Clear the table on error
                // Optionally show a non-blocking warning:
                // showError('Warning: Could not load high-cost records. ' + error.message);
            }
        }

        // Initialize Application on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM fully loaded and parsed');

            // Get references to DOM elements
            dateRangePicker = document.getElementById('dateRangePicker');
            modelFilter = document.getElementById('modelFilter');
            applyFiltersBtn = document.getElementById('applyFilters');
            loadingOverlay = document.getElementById('loadingOverlay');
            loadingMessage = document.getElementById('loadingMessage');
            errorAlert = document.getElementById('errorAlert');
            errorMessage = document.getElementById('errorMessage');
            totalRequestsEl = document.getElementById('totalRequests');
            totalTokensEl = document.getElementById('totalTokens');
            totalCostEl = document.getElementById('totalCost');
            avgCostEl = document.getElementById('avgCost');
            tableBody = document.getElementById('tableBody');
            highCostTableBody = document.getElementById('highCostTableBody');

            // Check if all essential elements were found
            if (!dateRangePicker || !modelFilter || !applyFiltersBtn || !loadingOverlay || !errorAlert) {
                console.error('Essential UI elements not found! Dashboard may not function correctly.');
                // Display a critical error message to the user
                const body = document.querySelector('body');
                if (body) {
                    body.innerHTML = '<div class="alert alert-danger" role="alert">Critical Error: Dashboard UI elements are missing. Please check the HTML structure or contact support.</div>' + body.innerHTML;
                }
                return; // Stop initialization
            }

            // Initialize charts
            initCharts();
            
            // Setup Apply Filters button listener
            applyFiltersBtn.addEventListener('click', function() {
                console.log('Apply Filters button clicked');
                // Date range is updated by the daterangepicker callback
                // Model is read directly from the select element
                loadData(); // Trigger data reload with current filter values
            });

            // Initialize date range picker (which triggers model load and initial data load)
            // Use a small timeout to ensure libraries are fully ready
            setTimeout(initDateRangePicker, 100); 
        });

    </script>

</body>
</html>
